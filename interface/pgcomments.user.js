/*Add blog post trackbacks to PubMed pages*/// ==UserScript==// @name			Postgenomic / Pubmed mashup// @namespace		http://www.postgenomic.com/userscripts// @description		Adds blog post trackbacks to papers on PubMed// @include			http://www.ncbi.nlm.nih.gov/entrez/*// ==/UserScript==// Get current datevar d = new Date();var curr_date = d.getDate();var stored_date=0;var stored_date= GM_getValue("postgenomics_data_date", 0);// Check for new DOIs in Postgenomic only once per day// So if the current date != the date in the cache, refresh the cacheif ( (stored_date != curr_date) || (!GM_getValue("postgenomics_json_list",0)) ) {	get_ids();	GM_setValue("postgenomics_data_date", curr_date); // in JSON format} else {	eval(GM_getValue("postgenomics_json_list",0));}function process_api_results(obj) {	GM_log("Got data, starting Postgenomic greasemonkey script.");		var dois = new Array();	var pmids = new Array();	// ignore OAI ids for now		dois = obj.doi_id; // an array of doi => paper_id	pmids = obj.pubmed_id; // an array of PMID => paper_id			evaluate_page(dois, pmids);}function process_posts(obj) {	var header = document.getElementById("GM_postgenomic");		for (var i=0; i < obj.length; i++) {		var title = obj[i].title;		var blog_name = obj[i].blog_name;		var pubdate = obj[i].pubdate;		var link = obj[i].url;				var post = document.createElement('li');		post.innerHTML = '<a style="color: #1919B3;" href="' + link + '">' + title + '</a> in ' + blog_name;		header.appendChild(post);	}}function find(pattern, subject) {	var reg = new RegExp(pattern, "i")	var match = reg.exec(subject);	return match; // returns an array (potentially empty)}function found_paper(paper_id) {	var header = document.createElement('div');	header.innerHTML = '<div id="GM_postgenomic" style="font-family: arial; font-size: 14px; background-color: #E6ECFF; color: #000000; border: 1px dotted #BFCFFF; padding: 5px; margin: 2px; margin-top: 15px;">' +'<b>Trackbacks</b><br/>' +'This paper has been cited on <a style="color: #1919B3;" href="http://www.postgenomic.com/">Postgenomic</a>.' +'<p><br/></div>';	var allPMIDs = document.evaluate(		"//p[@class='pmid']",	    document,	    null,	    XPathResult.UNORDERED_NODE_SNAPSHOT_TYPE,	    null);		if (allPMIDs.snapshotLength) {		var lastPMID = allPMIDs.snapshotItem((allPMIDs.snapshotLength - 1));		lastPMID.appendChild(header);	} else {		// not sure where to put the script output... we'll just dump it at the top of the page.		document.body.insertBefore(header, document.body.firstChild);			} 	get_posts(paper_id);		}function evaluate_page(dois, pmids) {	GM_log("Evaluate page is running.");		// first check the page URL	var page_url = unescape(location.href);	var match = find("list_uids=(\\d+)", page_url);	if (match) {		var pubmed_id = match[1];		if (pmids[pubmed_id]) {			found_paper(pmids[pubmed_id]);			return;		} else {			GM_log("Found pubmed id " + pubmed_id + " but it isn't in the Postgenomic index.");		}			} else {		GM_log("Didn't find a match");	}		// Look for any PMIDs in the text	GM_log("Looking for PMID in text");	var allLinks, thisLink;	var pmids_found = new Array();	allLinks = document.evaluate(		"//p[@class='pmid']",	    document,	    null,	    XPathResult.UNORDERED_NODE_SNAPSHOT_TYPE,	    null);	for (var i = 0; i < allLinks.snapshotLength; i++) {	    thisLink = allLinks.snapshotItem(i);	    // do something with thisLink		GM_log("Found a PMID in text " + thisLink.textContent);		var match = find("PMID: (\\d+)", thisLink.textContent);		if (match) {			var pubmed_id = match[1];			pmids_found.push(pubmed_id);		} else {			GM_log("Found a PMID in text but it didn't match the regexp.");		}	}		// we're only interested in pages where a single Pubmed ID is listed.	if (pmids_found.length == 1) {		var pubmed_id = pmids_found[0];		if (pmids[pubmed_id]) {			found_paper(pmids[pubmed_id]);			return;		} else {			GM_log("Found single pubmed id " + pubmed_id + " in text but it isn't in the Postgenomic index.");		}	}			return;		var allLinks, thisLink;	allLinks = document.evaluate(		"//a[@href]",	    document,	    null,	    XPathResult.UNORDERED_NODE_SNAPSHOT_TYPE,	    null);	for (var i = 0; i < allLinks.snapshotLength; i++) {	    thisLink = allLinks.snapshotItem(i);	    // do something with thisLink		GM_log("Found a link " + thisLink.textContent);	}	}// this function retrieves details of posts that cite a particular paper_idfunction get_posts(paper_id){	GM_log("Requesting posts");	var request_url = "http://www.postgenomic.com/api.php?type=post&citing_paper=" + paper_id + "&format=json&callback=process_posts&about=fnl_pubmed_trackbacks";	GM_log(request_url);	GM_xmlhttpRequest({		method: 'GET',		url: request_url,		headers: {			'User-agent': 'Mozilla/4.0 (compatible) Greasemonkey',			'Accept': 'application/xml,text/html',		},		onload: function(responseDetails) {			var response_status=responseDetails.status;			var response_text=null;			if (response_status==200){				GM_log("Posts request: response ok");				response_text=responseDetails.responseText;				eval(response_text);			}		}	});}// this function retrieves details of papers in the Postgenomic index in JSON format.function get_ids(){	GM_log("Requesting IDs");	GM_xmlhttpRequest({		method: 'GET',		url: "http://www.postgenomic.com/api.php?type=paper&ids_only=1&callback=process_api_results&about=fnl_pubmed_trackbacks",		headers: {			'User-agent': 'Mozilla/4.0 (compatible) Greasemonkey',			'Accept': 'application/xml,text/html',		},		onload: function(responseDetails) {			var response_status=responseDetails.status;			var response_text=null;			if (response_status==200){				GM_log("IDs request: response ok");				response_text=responseDetails.responseText;							GM_setValue("postgenomics_json_list", response_text);				eval(response_text);			}		}	});}